//   12/2/25 - Rev 1 - working code with sudo stock prices on a 8 x 64 array of LED's 
//           Generated partially from perplexity and Claude 
//           Further characterization of current draw on LED's needs to be performed to optimze power supply requirements, currently using 5V/8A (40W) supply
//           Using ESP32-S3 development board with data pin connected to GPIO pin 16, goal is to have this product standalone
//           - Rev 2 - adding Wifi connectivity and real time stock market data
//   12/3/25 - Rev 3 - switched to Finnhub API (much faster, 60 requests/minute
//   12/4/25 - Rev 4 - updated loading to only occur on initial boot, implemented dual core so updates happen independent of scrolling text. 

#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <Adafruit_GFX.h>
#include <Adafruit_NeoMatrix.h>
#include <Adafruit_NeoPixel.h>

// WiFi credentials - CHANGE THESE TO YOUR NETWORK
const char* ssid = "inventopia100";
const char* password = "sweatequity";

// Finnhub API Key - GET FREE KEY AT: https://finnhub.io/register
const char* finnhubKey = "d4ocbmpr01quuso8tlkgd4ocbmpr01quuso8tll0";


#define PIN 16
#define WIDTH 64
#define HEIGHT 8

// Create matrix object for two daisy-chained 32x8 matrices
Adafruit_NeoMatrix matrix = Adafruit_NeoMatrix(
  WIDTH, HEIGHT, PIN,
  NEO_MATRIX_TOP + NEO_MATRIX_LEFT +
  NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG,
  NEO_GRB + NEO_KHZ800
);

// Stock data structure
struct Stock {
  String symbol;
  float price;
  float changePercent;
  float previousClose;
};

// Stock symbols to track
Stock stocks[8];
const String stockSymbols[] = {"SPY", "QQQ", "TSM", "VOO", "MU", "NVDA", "GOOGL", "MSFT"};
const int numStocks = 8;

int x = WIDTH;
int currentStock = 0;
char displayText[50];
unsigned long lastUpdate = 0;
const unsigned long updateInterval = 60000; // Update every 60 seconds
bool isInitialBoot = true;

// Task handle for background updates
TaskHandle_t updateTaskHandle = NULL;
bool updateTaskRunning = false;

// Function to display a message on the LED matrix
void showMessage(const char* message, uint16_t color, int duration) {
  matrix.fillScreen(0);
  matrix.setTextColor(color);
  matrix.setCursor(0, 0);
  matrix.print(message);
  matrix.show();
  delay(duration);
}

void connectToWiFi() {
  Serial.print("Connecting to WiFi");
  WiFi.begin(ssid, password);
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 30) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nWiFi Connected!");
    Serial.print("IP Address: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("\nWiFi Connection Failed!");
  }
}

bool fetchSingleStock(int index) {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi not connected!");
    return false;
  }
  
  String symbol = stockSymbols[index];
  Serial.print("Fetching data for: ");
  Serial.println(symbol);
  
  HTTPClient http;
  
  // Finnhub Quote endpoint
  String url = "https://finnhub.io/api/v1/quote?symbol=";
  url += symbol;
  url += "&token=";
  url += finnhubKey;
  
  http.begin(url);
  http.setTimeout(10000);
  
  int httpCode = http.GET();
  
  if (httpCode == 200) {
    String payload = http.getString();
    
    // Parse JSON
    DynamicJsonDocument doc(1024);
    DeserializationError error = deserializeJson(doc, payload);
    
    if (!error) {
      float currentPrice = doc["c"]; // current price
      float previousClose = doc["pc"]; // previous close
      float changePercent = doc["dp"]; // percent change
      
      // Check if we got valid data
      if (currentPrice > 0) {
        // Update stock data
        stocks[index].symbol = symbol;
        stocks[index].price = currentPrice;
        stocks[index].previousClose = previousClose;
        stocks[index].changePercent = changePercent;
        
        Serial.printf("%s: $%.2f (%+.2f%%)\n", symbol.c_str(), currentPrice, changePercent);
        http.end();
        return true;
      } else {
        Serial.println("Error: Invalid data received (price = 0)");
        Serial.println("Response: " + payload);
        http.end();
        return false;
      }
    } else {
      Serial.print("JSON parsing failed: ");
      Serial.println(error.c_str());
      Serial.println("Response: " + payload);
      http.end();
      return false;
    }
  } else {
    Serial.printf("HTTP Error: %d\n", httpCode);
    if (httpCode > 0) {
      Serial.println("Response: " + http.getString());
    }
    http.end();
    return false;
  }
}

bool updateAllStocks(bool showProgress) {
  Serial.println("\n=== Updating Stock Data ===");
  int successCount = 0;
  
  for (int i = 0; i < numStocks; i++) {
    // Show progress on LED matrix only if requested (initial boot)
    if (showProgress) {
      char progressMsg[20];
      snprintf(progressMsg, sizeof(progressMsg), "%d/%d %s", i+1, numStocks, stockSymbols[i].c_str());
      showMessage(progressMsg, matrix.Color(0, 255, 255), 500);
    }
    
    bool success = fetchSingleStock(i);
    if (success) {
      successCount++;
    } else {
      Serial.println("Failed to fetch " + stockSymbols[i]);
    }
    
    // Small delay between requests (1 second is safe for 60/min limit)
    delay(1000);
  }
  
  Serial.printf("=== Stock Update Complete: %d/%d successful ===\n\n", successCount, numStocks);
  return (successCount > 0); // Return true if at least one stock succeeded
}

// Background task for stock updates (runs on Core 0)
void updateStocksTask(void * parameter) {
  while (true) {
    if (updateTaskRunning) {
      Serial.println("\n--- Background stock refresh task started ---");
      updateAllStocks(false); // Silent update, no progress display
      updateTaskRunning = false;
      Serial.println("--- Background refresh task complete ---\n");
    }
    delay(100); // Small delay to prevent task from hogging CPU
  }
}

void setup() {
  Serial.begin(115200);
  Serial.println("\n\nESP32 Stock Ticker - Finnhub API");
  Serial.println("Get your free API key at: https://finnhub.io/register");
  
  // Initialize stock symbols with default values
  for (int i = 0; i < numStocks; i++) {
    stocks[i].symbol = stockSymbols[i];
    stocks[i].price = 0.0;
    stocks[i].changePercent = 0.0;
    stocks[i].previousClose = 0.0;
  }
  
  // Initialize matrix
  matrix.begin();
  matrix.setTextWrap(false);
  matrix.setBrightness(30);
  matrix.setTextColor(matrix.Color(0, 255, 100));
  
  // Connect to WiFi
  connectToWiFi();
  
  // Show WiFi status on LED matrix
  if (WiFi.status() == WL_CONNECTED) {
    showMessage("WIFI OK", matrix.Color(0, 255, 0), 2000);
  } else {
    showMessage("WIFI FAIL", matrix.Color(255, 0, 0), 3000);
    return; // Don't continue if WiFi failed
  }
  
  // Initial stock data fetch (takes ~10 seconds for 8 stocks)
  // Show progress only on initial boot
  bool success = updateAllStocks(true);
  
  if (success) {
    showMessage("READY!", matrix.Color(0, 255, 0), 2000);
    isInitialBoot = false; // Mark initial boot as complete
  } else {
    showMessage("DATA FAIL", matrix.Color(255, 0, 0), 3000);
  }
  
  // Create background task for stock updates on Core 0
  // Display runs on Core 1 (default loop() core)
  xTaskCreatePinnedToCore(
    updateStocksTask,   // Task function
    "UpdateStocks",     // Task name
    10000,              // Stack size
    NULL,               // Parameters
    1,                  // Priority
    &updateTaskHandle,  // Task handle
    0                   // Core 0 (loop runs on Core 1)
  );
  
  Serial.println("Background update task created on Core 0");
}

void loop() {
  // Trigger background update every 60 seconds (runs on separate core)
  if (!isInitialBoot && !updateTaskRunning && (millis() - lastUpdate > updateInterval)) {
    Serial.println("Triggering background update...");
    updateTaskRunning = true;
    lastUpdate = millis();
  }
  
  // Display stock ticker (runs continuously on Core 1, never blocked)
  matrix.fillScreen(0);
  
  // Format stock text: "SPY $485.20 +0.74%  "
  if (stocks[currentStock].price > 0) {
    snprintf(displayText, sizeof(displayText), "%s $%.2f %+.2f%%  ", 
            stocks[currentStock].symbol.c_str(), 
            stocks[currentStock].price, 
            stocks[currentStock].changePercent);
  } else {
    snprintf(displayText, sizeof(displayText), "%s LOADING...  ", 
            stocks[currentStock].symbol.c_str());
  }
  
  // Set color based on change
  if (stocks[currentStock].changePercent > 0) {
    matrix.setTextColor(matrix.Color(0, 255, 0));  // Green
  } else if (stocks[currentStock].changePercent < 0) {
    matrix.setTextColor(matrix.Color(255, 0, 0));  // Red
  } else {
    matrix.setTextColor(matrix.Color(255, 255, 0)); // Yellow
  }
  
  matrix.setCursor(x, 0);
  matrix.print(displayText);
  
  // Scroll left
  if(--x < -150) {
    x = matrix.width();
    currentStock = (currentStock + 1) % numStocks;
  }
  
  matrix.show();
  delay(50);
}
